/***********************************************************
This procedure is generated by the query 51 template
in TPC-DS. This query is to compute the count of store sales 
resulting from promotions, the count of all store sales and 
their ratio for specific categories in a particular time 
zone and for a given year and month.
the scalar parameter is threshold.

The detail steps for generating the procedure with loops 
by transforming CTE query are as follows. Each CTE table
variable is transformed to the SQL assignment statement
Then, each query with table variables is decomposed.

In addition, we only caclulates web_v1 and store_v1  
when the the count of date between 1192 ~ 1192+11 
is bigger than threshold for adding branch to block inlining.
**************************************************************/
create procedure "func5_if"(in threshold integer) as begin
declare date_cnt integer;
select count(*) into date_cnt from date_dim where d_month_seq BETWEEN 1192 AND      1192+11;
if :date_cnt > :threshold then
web_v1 = SELECT   ws_item_sk item_sk, 
                  d_date, 
                  sum(Sum(ws_sales_price)) OVER (partition BY ws_item_sk ORDER BY d_date rows BETWEEN UNBOUNDED PRECEDING AND      CURRENT row) cume_sales
         FROM     web_sales , 
                  date_dim 
         WHERE    ws_sold_date_sk=d_date_sk 
         AND      d_month_seq BETWEEN 1192 AND      1192+11 
         AND      ws_item_sk IS NOT NULL 
         GROUP BY ws_item_sk, 
                  d_date;
 
 store_v1 =       SELECT   ss_item_sk item_sk, 
                  d_date, 
                  sum(sum(ss_sales_price)) OVER (partition BY ss_item_sk ORDER BY d_date rows BETWEEN UNBOUNDED PRECEDING AND      CURRENT row) cume_sales
         FROM     store_sales , 
                  date_dim 
         WHERE    ss_sold_date_sk=d_date_sk 
         AND      d_month_seq BETWEEN 1192 AND      1192+11 
         AND      ss_item_sk IS NOT NULL 
         GROUP BY ss_item_sk, 
                  d_date;           
end if;
v3 = SELECT  CASE  WHEN web.item_sk IS NOT NULL THEN web.item_sk ELSE store.item_sk  END item_sk , 
             CASE  WHEN web.d_date IS NOT NULL THEN web.d_date ELSE store.d_date  END d_date , 
             web.cume_sales   web_sales , store.cume_sales store_sales 
              FROM   :web_v1 web 
              FULL OUTER JOIN :store_v1 store 
              ON ( web.item_sk = store.item_sk AND web.d_date = store.d_date);
v4 = SELECT   item_sk , 
                           d_date , 
                           web_sales , 
                           store_sales , 
                           max(web_sales) OVER (partition BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED PRECEDING AND      CURRENT row)   web_cumulative ,
                           max(store_sales) OVER (partition BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED PRECEDING AND      CURRENT row) store_cumulative
                           from :v3;              
              
SELECT  * FROM :v4 WHERE web_cumulative > store_cumulative ORDER BY item_sk , d_date 
LIMIT 100; 
end;